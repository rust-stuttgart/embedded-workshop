# Introduction
(feel free to skip sections you know about)

## Scope

The following topics are covered in the core chapters:

- How to write, build and flash an embedded program.
- Basic operation of a GPIO, ubiquitous in microcontrollers.

## Non-goals

- Teaching electric circuit theory or electronics.

  We'll cover the minimum required to understand how some devices work along the way.

- Covering Rustic, low level details.

  We won't be talking about linker scripts, the boot process,
  or how to glue those two into a minimally working Rust program.

## What is a microcontroller?

Microcontrollers are small computers, complete with some storage, ram and
peripherals. In contrast to usual PCs, they're pretty cheap (0.05€ to 20€),
don't have much of an os (some of the more advanced ones can run a stripped down
version of linux) and are often remain unnoticed.

They're used in a wide range of products, like:
- Electric Toothbrushes
- Controlling the backlight of LCDs
- Flashlights
- Controlling fuel injection in cars
and much more.

Pretty much everything with electronics in it has a microcontroller, simply
because they're so cheap and versatile.

These are usually bare-metal environments, where no operating system is present
and on power on, the processor jumps to the user code. <sup><a id="fnr.1"
class="footref" href="#fn.1">1</a></sup>

Most MCUs (MicroController Units) today are programmed in C or a very C-like C++, since the
ecosystem is typically 10-20 years behind modern software development (for
better or for worse).

TODO:
- Photo
- Peripheral explanation
## Rust

This book is meant to be understandable for non-rust users, but not sufficient
for doing anything with the information contained herein. For learning rust
itself, the [Rust Book](https://doc.rust-lang.org/book/) is often recommended.
While the syntax will no be explained, a couple necessary key concepts are listed here:
- [Traits](https://doc.rust-lang.org/reference/items/traits.html)

  Traits are comparable to interfaces in other languages

- [Crates](https://doc.rust-lang.org/reference/crates-and-source-files.html)

  Crates are the compilation unit of the rust compiler and can either be
  runnable binaries or libraries to be used in other crates

- no_std
  
  The default rust standard library `std` contains features that aren't
  necessarily available on all targets, such as memory allocation or network support.
  For such targets, a stripped down version, `core`, is provided, that only
  contains features that don't require os support.

TODO: 
- expand
So, why rust?
Well:
1. Just because
2. Proper dependency managment, and thanks to [embedded-hal](https://github.com/rust-embedded/embedded-hal)

## Rust embedded ecosystem
The rust embedded ecosystem, as propagated by the
[embedded-wg](https://github.com/rust-embedded/wg), is based on several
foundational crates (we're only considering arm devices here):
- [`cortex-m`](https://github.com/rust-embedded/cortex-m) and
  [`cortex-m-rt`](https://github.com/rust-embedded/cortex-m-rt)

  These crates provide abstractions for the ARM Cortex-M cpus and the runtime.
  This includes initializing ram, implementing interrupts and much more.

- [`embedded-hal`](https://github.com/rust-embedded/embedded-hal)

  The embedded-hal crate includes various traits, that can be used by device
  drivers to interface with external components, without being the specific to
  one MCU. The traits are usually implement by a microcontroller-specific hal.

- PACs

  The Peripheral Access Crates are used as a basic interface to the registers of
  the peripherals included in the microcontroller. Most are generated using
  [svd2rust](https://github.com/rust-embedded/svd2rust), which translated a
  manufacturer-provided
  [svd](https://www.keil.com/pack/doc/CMSIS/SVD/html/svd_Format_pg.html) file to
  rust code.

- HALs

  Hardware Abstraction Libraries wrap the code generated by the PACs into
  something more usable and provide safe abstractions for the peripherals. These
  abstractions usually consist of some chip-specific setup and an implementation
  of the matching `embedded-hal` traits for actually using the peripheral

There are also some other ecosystems, which aren't discussed here, but are also useful:
- [TockOS](https://www.tockos.org/)

  TODO

- [Bobbin](https://github.com/bobbin-rs/)


Most of the crates in the rust embedded ecosystem are listed in the
[awesome-embedded-rust list](https://github.com/rust-embedded/awesome-embedded-rust).
# Footnotes
<sup><a id="fn.1" href="#fnr.1">1</a></sup> This isn't always technically
correct. Many include a small bootloader or some very basic initialization code.
